---
title: "QC"
output:
  html_document:
    theme: yeti # A clean and modern theme from Bootswatch
    highlight: tango  # Syntax highlighting style
    code_folding: hide  # Collapsible code blocks
    toc: true  # Include a table of contents
    toc_depth: 3  # Show TOC up to level 3 headings
    toc_float: true  # Make the TOC float while scrolling
    css: custom.css  # Link to your custom CSS file
params:
  args: ''
  sequencing: ''
  dark_mode: true  # Add parameter for enabling dark mode
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(plotly)

color_palette <- c(
  "#E69F00", # Orange
  "#56B4E9", # Sky Blue
  "#009E73", # Green
  "#F0E442", # Yellow
  "#0072B2", # Blue
  "#D55E00", # Vermilion
  "#CC79A7", # Reddish Purple
  "#999999", # Gray
  "#000000", # Black
  "#A6761D", # Brown
  "#1B9E77", # Dark Green
  "#D95F02", # Dark Orange
  "#7570B3", # Violet
  "#E7298A", # Magenta
  "#66A61E"  # Lime Green
)
args <-  params$args
output_dir <- args[1]

samples <- list.files(output_dir)

```

# Quality control
## DNA contamination
On of the largest caveats in RNA sequencing, and extracellular RNA sequencing especially, is DNA contamination. Luckily, we can determine the extent of this problem by investigation the metrics of our output. None of these metrics on their own can determine DNA contamination but, together, they can indicate an issue.

### Strandedness
Many RNA sequencing library preparation protocols use a stranded approach. This means that the reads generated from a transcript map specifically to either the coding or template strand. The SMARTer® Stranded Total RNA-Seq Kit - Pico Input Mammalian, for example, is a stranded protocol. When sequencing DNA, both strands will be sequenced and your stranded library preparation becomes unstranded. Ideally, the fraction of "reads mapped to template strand" is close to 1. The closer this value gets to 0.5, the more likely your data contains some DNA data.

```{r strandedness, echo = FALSE}
strandedness <- tibble()

for (sample in samples) {
  x <- read_table(paste0(output_dir, "/", sample, "/08_rseqc/", sample, "_strandedness.txt"), skip = 3, col_names = FALSE)$X7
  strandedness <- rbind(strandedness, 
                        tibble(sample = sample, 
                               type = factor(c("failed to determine", "1+-,1-+,2++,2--", "1++,1--,2+-,2-+"), levels = c("failed to determine", "1+-,1-+,2++,2--", "1++,1--,2+-,2-+")), 
                               fraction = x)
  )
}

ggplotly(strandedness %>%
  ggplot(aes(sample, fraction, fill = type)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  theme(axis.title = element_text(size = 15, color = "#264a6c"), 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 45), size = 13, color = "#264a6c") +
  xlab("") + 
  ylab("fraction of\ndeduplicated reads\n") +
  scale_fill_manual(values = color_palette))
```

### Splice reads
Since the kits used here are total RNA sequencing kits, we at least expect some of the reads to map to splice junctions. In case of DNA, there should be little to no reads mapping to splice junctions. 

```{r spliced_reads, echo = FALSE}
spliced_reads <- tibble()

for (sample in samples) {
  x <- read_table(paste0(output_dir, "/", sample, "/08_rseqc/", sample, "_raw_bam_stat.txt"), col_names = paste0("X", 1:5))
  spliced_reads <- rbind(spliced_reads,
                         tibble(type = c("non-splice", "splice"), 
                                reads = as.double(x$X3[15:16]), 
                                sample = sample)
                         )
}

ggplotly(spliced_reads %>%
  group_by(sample) %>%
  mutate(fraction = reads / sum(reads)) %>%
  ungroup() %>%
  ggplot(aes(sample, fraction, fill = type)) +
  geom_bar(stat = "identity") +
  theme_minimal() + 
  theme(axis.title = element_text(size = 15, color = "#264a6c"), 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, 
                                   size = 13, color = "#264a6c")) +
  xlab("") + 
  ylab("fraction of raw reads\n") +
  scale_fill_manual(values = color_palette))
```

### Duplication rates
The duplication rate represents the number of unique RNA molecules that were sequenced. Because of the low RNA concentration used in this kit, the percentage of duplicates can be quite high. However, a sample strongly deviating from others in terms of duplication rate, might indicate an issue.

```{r duplication, echo=FALSE}
duplication <- tibble()

sequencing <- params$sequencing #sequencing mode (se or pe)

for (sample in samples) {

  umi_file <- file.path(output_dir, sample, "04_dedup", "umidedup.txt")
  picard_file <- file.path(output_dir, sample, "04_dedup", "picarddedup.txt")

  if (sequencing == "pe" && file.exists(umi_file)) {
    # UMI-tools mode (paired-end)
    x <- read_table(umi_file, col_names = paste0("X", 1:8)) %>%
      tail(n = 6) %>% head(n = 2)

    # Total reads = "Read" row (X8 == "Read"), numeric part of X7
    total <- as.numeric(str_remove(x$X7[x$X8 == "Read"], ","))
    unique <- as.numeric(x$X8[x$X8 == "Unique"])  # unique reads are in X8 #previously: x$X8 != "Read"

    duplication <- rbind(
      duplication,
      tibble(
        sample = sample,
        total = total,
        unique = unique,
        removed = (total - unique) / total
      )
    )

  } else if (sequencing == "se" && file.exists(picard_file)) {
    # Picard mode (single-end)
    x <- suppressMessages(
      read_table(
        picard_file,
        comment = "#",
        col_names = TRUE,
        col_types = cols(
          LIBRARY = col_character(),
          UNPAIRED_READS_EXAMINED = col_double(),
          READ_PAIRS_EXAMINED = col_double(),
          SECONDARY_OR_SUPPLEMENTARY_RDS = col_double(),
          UNMAPPED_READS = col_double(),
          UNPAIRED_READ_DUPLICATES = col_double(),
          READ_PAIR_DUPLICATES = col_double(),
          READ_PAIR_OPTICAL_DUPLICATES = col_double(),
          PERCENT_DUPLICATION = col_double(),
          ESTIMATED_LIBRARY_SIZE = col_double()
	)
      )
    )

    total <- sum(x$UNPAIRED_READS_EXAMINED, na.rm=T)
    dup <- sum(x$UNPAIRED_READ_DUPLICATES, na.rm=T)

    duplication <- rbind(
      duplication,
      tibble(
        sample = sample,
        total = total,
        unique = total - dup,
        removed = dup / total
      )
    )
  } else {
    message("Skipping ", sample, ": no dedup file found.")
  }
}

if (nrow(duplication) == 0) {
  cat("**No duplication files found — skipping duplication plot.**")
} else {
  ggplotly(
    duplication %>%
      ggplot(aes(x = TRUE, y = removed, group = sample)) +
      geom_boxplot(outliers = FALSE, fill = "#264a6c") +
      geom_jitter(width = 0.1, height = 0, shape = 21,
                  col = "white", fill = "#264a6c", size = 4) +
      theme_minimal() +
      theme(axis.title = element_text(size = 15, color = "#264a6c"),
            axis.text.x = element_blank()) +
      ylab("\nFraction of reads removed after deduplication\n") +
      xlab("") +
      ylim(0, 1)
  )
}
```

### Spike fraction
The spike fraction indicates the percentage of counts assigned to the spike-in RNAs. Ideally, the spikes take up a portion of the data large enough to be able to perform downsteam analyses, such as normalization. However, exceedingly high spike fractions hoard an excessive amount of data, leaving little for true biological reads. 
```{r spike_fraction, echo = FALSE}

counts <- tibble()

for (sample in samples) {
  counts <- rbind(counts,
                  read_table(paste0(output_dir, "/", sample, "/05_count/", sample, "_htseq_dedup_counts.txt"), col_names = c("target", "count")) %>% mutate(sample = str_extract(sample, "RNA[0-9]+")))
}

ggplotly(counts %>%
  filter(!grepl("__", target)) %>%
  mutate(group = ifelse(grepl("^R", target), 'sequin',
                        ifelse(grepl("ERCC", target), 'ERCC', 'human'))) %>%
  group_by(sample, group) %>%
  summarise(total_counts = sum(count)) %>%
  ungroup() %>%
  group_by(sample) %>%
  mutate(fraction = total_counts / sum(total_counts),
         group = factor(group, levels = c("human", "ERCC", "sequin"))) %>%
  ungroup() %>%
  filter(group != "human") %>%
  ggplot(aes(sample, fraction, fill = group)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 13, color = "#264a6c"),
        axis.title.y  = element_text(size = 15, color = "#264a6c"),
        strip.text  = element_text(size = 15, color = "#264a6c"),
        axis.text.x = element_text(angle = 45, hjust = 1, 
                                   size = 13, color = "#264a6c")) +
  xlab("") + 
  ylab("fraction of unique counts\n") +
  facet_wrap(~group, scales = "free") +
  scale_fill_manual(values = color_palette))
```


